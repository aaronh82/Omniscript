//
//  JSON.cpp
//  OmniScript
//
//  Created by Aaron Houghton on 6/30/14.
//  Copyright (c) 2014 CCBAC. All rights reserved.
//

#include "JSON.h"
#include "Logger.h"

#include <exception>

namespace util {
	
	Json::Value JSON::root_;
	
	bool JSON::parse(std::istream* is) {
		Json::Reader reader;
		return reader.parse(*is, root_);
	}
	
	std::vector<block_ptr> JSON::build(std::istream *is) {
		if (!parse(is)) {
			LOG(Log::ERROR, "Failed to parse JSON");
		}
		const Json::Value scriptRoot = root_["scripts"];
		std::vector<block_ptr> startingBlocks;
		for (auto &root_iter : scriptRoot) {
			for (auto &script : root_iter) {
				
				if (script.isArray()) {
					startingBlocks.emplace_back(getInnerBlocks(script));
				}
			}
		}
		return startingBlocks;
	}
	
	block_ptr JSON::getInnerBlocks(const Json::Value &specs, bool nested) {
		block_ptr startBlock, curBlock;
		
		for (auto &inner : specs) {
			block_ptr newBlock(new blocks::Block);
			
			getOpArgs(inner, newBlock);
			
			if (curBlock == nullptr) {
				startBlock = newBlock;
				curBlock = startBlock;
			} else {
				curBlock->next(newBlock);
				curBlock = curBlock->next();
			}
		}
		
		if (!nested) {
			curBlock->next(startBlock);
		}
		
		return startBlock;
	}
	
	void JSON::getOpArgs(Json::Value specs, block_ptr &curBlock) {
		std::vector<std::string> args;
		std::vector<block_ptr> blockArgs;
		std::string opStr;
		int i(0);
		
		auto opArg = std::begin(specs);
		for (auto end = std::end(specs); opArg != end; ++opArg) {
			if (opArg == specs.begin()) {
				if ((*opArg).isArray()) {
					curBlock->setOpcode("nested");
					curBlock->addNestedStart(getInnerBlocks(specs, true));
				} else {
					curBlock->setOpcode((*opArg).asString());
				}
			} else {
				if ((*opArg).isArray()) {
					block_ptr b(new blocks::Block);
					getOpArgs(*opArg, b);
					if (b->opcode() == "nested") {
						curBlock->addNestedStart(b->nestedBlocks()[0]);
					} else {
						opStr = "block:" + std::to_string(i++);
						blockArgs.push_back(b);
					}
				} else if ((*opArg).isNumeric()) {
					opStr = std::to_string((*opArg).asDouble());
				} else {
					opStr = (*opArg).asString();
				}
				
				if (!opStr.empty()) {
					args.push_back(opStr);
				}
			}
		}
		if (args.size() > 0) curBlock->setArgs(args);
		if (blockArgs.size() > 0) curBlock->setBlockArgs(blockArgs);
	}
	
	std::vector<std::shared_ptr<interp::Variable> > JSON::getVars(std::istream *is) {
		const Json::Value varRoot = root_["variables"];
		std::vector<std::shared_ptr<interp::Variable> > variables;
		for (auto var : varRoot) {
			variables.emplace_back(std::make_shared<interp::Variable>(var["name"].asString(),
																	  var["type"].asString(),
																	  var["value"].asDouble()));
		}
		return variables;
	}
	
	std::vector<std::shared_ptr<interp::Point> > JSON::getPoints(std::istream *is) {
		const Json::Value pointRoot = root_["points"];
		std::vector<std::shared_ptr<interp::Point> > points;
		for (auto point: pointRoot) {
			points.emplace_back(std::make_shared<interp::Point>(point["name"].asString(),
																point["type"].asString(),
																point["value"].asDouble(),
																point["pointId"].asUInt(),
																point["typeId"].asUInt(),
																point["deviceId"].asUInt(),
																point["pathId"].asUInt()));
		}
		return points;
	}
	
}